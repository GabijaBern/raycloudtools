// Copyright (c) 2020
// Commonwealth Scientific and Industrial Research Organisation (CSIRO)
// ABN 41 687 119 230
//
// Author: Kazys Stepanas, Tom Lowe
#ifndef RAYTRANSIENTFILTER_H
#define RAYTRANSIENTFILTER_H

#include "raylib/raylibconfig.h"

#include "raygrid.h"
#include "raycloud.h"
#include "rayellipsoid.h"
#include "rayellipsoidmark.h"

#include <atomic>
#include <limits>
#include <vector>

namespace ray
{
struct Cloud;
class Progress;

/// Mode selection for @c TransientFilter
enum class RAYLIB_EXPORT MergeType : int
{
  Oldest,
  Newest,
  Mininum,
  Maximum
};

/// Option for how the @c TransientFilter orders operations. The @c EllipseGrid filter is faster multi-threaded, but
/// uses more memory. The @c RayGrid strategy uses less memory.
enum class RAYLIB_EXPORT TransientFilterStrategy : int
{
  EllipseGrid,
  RayGrid
};

/// Parameter configuration structure for @c TransientFilter
struct RAYLIB_EXPORT TransientFilterConfig
{
  double voxel_size = 0.1;
  double num_rays_filter_threshold = 20;
  TransientFilterStrategy strategy = TransientFilterStrategy::EllipseGrid;
  MergeType merge_type = MergeType::Mininum;
  bool colour_cloud = true;
};

/// A filter which removes 'transient' points from a ray cloud. A transient point is one which is in conflict with
/// sample observations and rays passing through the observation. For example, transient points are generated by movable
/// objects in a ray cloud such as people moving through a scan or doors being openned and closed.
///
/// This version of the algorithm is adapted from the @c Cloud::filterTransients() in order to improve performance and
/// scalability.
class RAYLIB_EXPORT TransientFilter
{
public:
  TransientFilter(const TransientFilterConfig &config);
  ~TransientFilter();

  inline const TransientFilterConfig &config() const { return config_; }

  /// Query the transient ray results. Empty before @c filter() is called.
  inline const Cloud &transientCloud() const { return transient_; }
  /// Query the non-transient ray results. Empty before @c filter() is called.
  inline const Cloud &fixedCloud() const { return fixed_; }

  /// Perform the transient filtering on the given @p cloud using the configured @c TransientFilterStrategy .
  bool filter(const Cloud &cloud, Progress *progress = nullptr);

  /// Filter using @c TransientFilterStrategy::EllipseGrid regardless of the @c TransientFilterConfig value.
  bool filterWithEllipseGrid(const Cloud &cloud, Progress *progress);

  /// Filter using @c TransientFilterStrategy::RayGrid regardless of the @c TransientFilterConfig value.
  bool filterWithRayGrid(const Cloud &cloud, Progress *progress);

  /// Reset previous results. Memory is retained.
  void clear();

  /// Fill a @p grid with with rays from @p cloud . For each ray we add its index to each grid cell it traces through.
  ///
  /// The grid bounds must be set sufficiently large to hold the rays before calling. The grid resolution is also set
  /// before calling
  ///
  /// @param grid The grid to populate
  /// @param cloud The cloud which grid indices reference rays in.
  /// @param progress Optional progress tracker.
  static void fillRayGrid(Grid<size_t> *grid, const Cloud &cloud, Progress *progress = nullptr);

  /// Fill the @p grid with ellipsoids. For each ellipsoid we add its index to each grid cell it's axis aligned bounding
  /// box overlaps.
  ///
  /// The grid bounds must be set sufficiently large to hold the rays before calling. The grid resolution is also set
  /// before calling
  ///
  /// @param grid The grid to populate
  /// @param ellispoids The array of ellipsoids to fill the @p grid with.
  /// @param progress Optional progress tracker.
  static void fillEllipseGrid(Grid<size_t> *grid, const std::vector<Ellipsoid> &ellipsoids,
                              Progress *progress = nullptr);

private:
  void markIntersectedEllipsoidsWithEllipseGrid(const Cloud &cloud, Grid<size_t> &ellipse_grid, bool self_transient,
                                                Progress &progress);

  void markIntersectedEllipsoidsWithRayGrid(const Cloud &cloud, Grid<size_t> &ray_grid,
                                            std::vector<std::atomic_bool> &transient_marks, bool self_transient,
                                            Progress &progress);

  /// Finalise the cloud filter and populate @c transientResults() and @c fixedResults() .
  /// Templated on the boolean type to support @c bool and @c std::atomic_bool .
  template <typename BOOL>
  void finaliseFilter(const Cloud &cloud, const std::vector<BOOL> &transient_marks);

  /// Walk a ray
  void walkRay(const Cloud &cloud, const Grid<size_t> &grid, size_t ray_id);

  Cloud transient_;
  Cloud fixed_;
  TransientFilterConfig config_;
  std::vector<Ellipsoid> ellipsoids_;
  std::vector<EllipsoidMark> ellipsoids_marks_;
  std::vector<bool> transient_marks_;
};
}  // namespace ray

#endif  // RAYTRANSIENTFILTER_H
