// Copyright (c) 2020
// Commonwealth Scientific and Industrial Research Organisation (CSIRO)
// ABN 41 687 119 230
//
// Author: Kazys Stepanas, Tom Lowe
#ifndef RAYTRANSIENTFILTER_H
#define RAYTRANSIENTFILTER_H

#include "raylib/raylibconfig.h"

#include "raygrid.h"
#include "raycloud.h"
#include "rayoctreenode.h"

#undef RAYLIB_WITH_TBB
#define RAYLIB_WITH_TBB 0

#if RAYLIB_WITH_TBB
#include <tbb/spin_mutex.h>
#endif  // RAYLIB_WITH_TBB

#include <limits>
#include <vector>

/// Reduces the number of voxels an ellipsoid touches by storing an inverse transform into a space where the ellispoid
/// is spherical.
///
/// This uses more memory but seems to only reduce the voxels touch by well less than 1% so it doesn't seem worth it
/// at this time.
#define RAYLIB_ELLIPSOID_TRANSFORM 0

namespace ray
{
struct Cloud;
class Progress;
class IndexingOctreeNode;

/// Mode selection for @c TransientFilter
enum class RAYLIB_EXPORT TransientFilterType : int
{
  Oldest,
  Newest,
  Mininum,
  Maximum
};

/// Parameter configuration structure for @c TransientFilter
struct RAYLIB_EXPORT TransientFilterConfig
{
  double voxel_size;
  double num_rays_filter_threshold;
  TransientFilterType merge_type;
  bool colour_cloud;
};


///
class RAYLIB_EXPORT EllipsoidMark
{
public:
#if RAYLIB_WITH_TBB
  using Mutex = tbb::spin_mutex;
#endif  // RAYLIB_WITH_TBB

  inline explicit EllipsoidMark(size_t id = 0u)
    : id_(id)
    , first_intersection_time_(std::numeric_limits<double>::max())
    , last_intersection_time_(std::numeric_limits<double>::lowest())
    , hits_(0u)
#if RAYLIB_WITH_TBB
    , lock_(new Mutex)
#endif  // RAYLIB_WITH_TBB
  {}

  inline size_t id() const { return id_; }

  inline double firstIntersectionTime() const { return first_intersection_time_; }
  inline double lastIntersectionTime() const { return last_intersection_time_; }

  inline size_t hits() const { return hits_; }

  inline const std::vector<size_t> &passThroughIds() const { return pass_through_ids_; }

#if RAYLIB_ELLIPSOID_TRANSFORM
  inline const Eigen::Matrix4d &inverseTransform() const { return inverse_sphere_transform_; }
  inline void setInverseTransform(const Eigen::Matrix4d &inverse_transform)
  {
    inverse_sphere_transform_ = inverse_transform;
  }
#endif  // RAYLIB_ELLIPSOID_TRANSFORM

  void reset(size_t id = 0u);

  void sortPassThroughIds();

  void hit(size_t ray_id, double time);
  void passThrough(size_t ray_id);

private:
  std::vector<size_t> pass_through_ids_;
  size_t id_;
  double first_intersection_time_;
  double last_intersection_time_;
  size_t hits_;
#if RAYLIB_ELLIPSOID_TRANSFORM
  Eigen::Matrix4d inverse_sphere_transform_;
#endif  // RAYLIB_ELLIPSOID_TRANSFORM
#if RAYLIB_WITH_TBB
  std::shared_ptr<Mutex> lock_;
#endif  // RAYLIB_WITH_TBB
};

/// A filter which removes 'transient' points from a ray cloud. A transient point is one which is in conflict with
/// sample observations and rays passing through the observation. For example, transient points are generated by movable
/// objects in a ray cloud such as people moving through a scan or doors being openned and closed.
///
/// This version of the algorithm is adapted from the @c Cloud::filterTransients() in order to improve performance and
/// scalability.
class RAYLIB_EXPORT TransientFilter
{
public:
  TransientFilter(const TransientFilterConfig &config);
  ~TransientFilter();

  inline const TransientFilterConfig &config() const { return config_; }

  /// Query the transient ray results. Empty before @c filter() is called.
  inline const Cloud &transientResults() const { return transient_; }
  /// Query the non-transient ray results. Empty before @c filter() is called.
  inline const Cloud &fixedResults() const { return fixed_; }

  /// Perform the transient filtering on the given @p cloud.
  void filter(const Cloud &cloud, Progress *progress = nullptr);

  /// Reset previous results. Memory is retained.
  void clear();

private:
  void generateEllipsoidGrid(Grid<size_t> &grid, Progress &progress);
  IndexingOctreeNode *generateEllipsoidOctree(Progress &progress);

  void markIntersectedEllipsoids(const Cloud &cloud, Grid<size_t> &grid, bool self_transient, Progress &progress);
  void markIntersectedEllipsoids(const Cloud &cloud, const IndexingOctreeNode &octree, bool self_transient,
                                 Progress &progress);

  void finaliseFilter(const Cloud &cloud);

  void walkRay(const Cloud &cloud, const Grid<size_t> &grid, size_t ray_id);

  void rayTouch(size_t ray_id, const Cloud &cloud, const OctreeNode::Ray &ray,
                const std::vector<size_t> &ellipsoid_ids);

  Cloud transient_;
  Cloud fixed_;
  TransientFilterConfig config_;
  std::vector<Ellipsoid> ellipsoids_;
  std::vector<EllipsoidMark> ellipsoids_marks_;
  std::vector<bool> transient_marks_;
};
}  // namespace ray

#endif  // RAYTRANSIENTFILTER_H
