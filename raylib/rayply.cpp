// Copyright (c) 2020
// Commonwealth Scientific and Industrial Research Organisation (CSIRO)
// ABN 41 687 119 230
//
// Author: Thomas Lowe
#include "rayply.h"
#include <iostream>
using namespace std;
using namespace Eigen;
using namespace RAY;

// Save the polygon file to disk
void RAY::writePly(const string &fileName, const vector<Vector3d> &starts, const vector<Vector3d> &ends, const vector<double> &times, const vector<RGBA> &colours)
{
  cout << "saving to " << fileName << ", " << ends.size() << " rays." << endl;
  
  vector<RGBA> RGB(times.size());
  if (colours.size() > 0)
    RGB = colours;
  else
    colourByTime(times, RGB);

  vector<Matrix<float, 9, 1> > vertices(ends.size()); // 4d to give space for colour
  bool warned = false;
  for (size_t i = 0; i<ends.size(); i++)
  {
    if (!warned)
    {
      if (!(ends[i] == ends[i]))
      {
        cout << "WARNING: nans in point: " << i << ": " << ends[i].transpose() << endl;
        warned = true;
      }
      if (abs(ends[i][0]) > 100000.0)
      {
        cout << "WARNING: very large point location at: " << i << ": " << ends[i].transpose() << ", suspicious" << endl;
        warned = true;
      }
      bool B = starts[i] == starts[i];
      if (!B)
      {
        cout << "WARNING: nans in start: " << i << ": " << starts[i].transpose() << endl;
        warned = true;
      }
    }
    Vector3d n = starts[i] - ends[i];

    union U // TODO: this is nasty, better to just make vertices an unsigned char vector
    {
      float f[2];
      double d;
    };
    U u;
    u.d = times[i];
    vertices[i] << (float)ends[i][0], (float)ends[i][1], (float)ends[i][2], (float)u.f[0], (float)u.f[1], (float)n[0], (float)n[1], (float)n[2], (float &)RGB[i];
  }
  ofstream out(fileName, ios::binary | ios::out);

  // do we put the starts in as normals?
  out << "ply" << endl; 
  out << "format binary_little_endian 1.0" << endl; 
  out << "comment generated by raycloudtools library" << endl;
  out << "element vertex " << vertices.size() << endl; 
  out << "property float x" << endl; 
  out << "property float y" << endl; 
  out << "property float z" << endl; 
  out << "property double time" << endl; 
  out << "property float nx" << endl; 
  out << "property float ny" << endl;
  out << "property float nz" << endl; 
  out << "property uchar red" << endl; 
  out << "property uchar green" << endl; 
  out << "property uchar blue" << endl; 
  out << "property uchar alpha" << endl; 
  out << "end_header" << endl; 

  out.write((const char *)&vertices[0], sizeof(Matrix<float, 9, 1>)*vertices.size());
}

bool RAY::readPly(const string &fileName, vector<Vector3d> &starts, vector<Vector3d> &ends, vector<double> &times, vector<RGBA> &colours)
{
  ifstream input(fileName.c_str());
  if (!input.is_open())
  {
    cerr << "Couldn't open file: " << fileName << endl;
    return false;
  }
  string line;
  int rowSize = 0;
  int offset = -1, normalOffset = -1, timeOffset = -1, colourOffset = -1;
  bool timeIsFloat = false;
  bool posIsFloat = false;
  bool normalIsFloat = false;
  while (line != "end_header\r" && line != "end_header")
  {
    getline(input, line);
    if (line.find("property float x") != string::npos || line.find("property double x") != string::npos)
    {
      offset = rowSize;
      if (line.find("float") != string::npos)
        posIsFloat = true;
    }
    if (line.find("property float nx") != string::npos || line.find("property double nx") != string::npos)
    {
      normalOffset = rowSize;
      if (line.find("float") != string::npos)
        normalIsFloat = true;
    }
    if (line.find("time") != string::npos)
    {
      timeOffset = rowSize;
      if (line.find("float") != string::npos)
        timeIsFloat = true;
    }
    if (line.find("property uchar red") != string::npos)
      colourOffset = rowSize;
    if (line.find("float") != string::npos)
      rowSize += int(sizeof(float));
    if (line.find("double") != string::npos)
      rowSize += int(sizeof(double));
    if (line.find("property uchar") != string::npos)
      rowSize += int(sizeof(unsigned char));
  }
  if (offset == -1)
  {
    cerr << "could not find position properties of file: " << fileName << endl;
    return false;
  }
  if (normalOffset == -1)
  {
    cerr << "could not find normal properties of file: " << fileName << endl;
    return false;
  }

  streampos start = input.tellg();
  input.seekg(0, input.end);
  size_t length = input.tellg() - start;
  input.seekg(start);
  size_t size = length / rowSize;
  vector<unsigned char> vertices(length);
  // read data as a block:
  input.read((char *)&vertices[0], length);
  bool timesNeedSorting = false;
  size_t numBounded = 0;
  size_t numUnbounded = 0;
  bool warningSet = false;
  for (size_t i = 0; i < size; i++)
  {
    Vector3d end;
    if (posIsFloat)
    {
      Vector3f e = (Vector3f &)vertices[rowSize*i + offset];
      end = Vector3d(e[0], e[1], e[2]);
    }
    else
      end = (Vector3d &)vertices[rowSize*i + offset];
    bool endValid = end==end;
    if (!warningSet)
    {
      if (!endValid)
      {
        cout << "warning, NANs in point " << i << ", removing all NANs." << endl;
        warningSet = true;
      }
      if (abs(end[0]) > 100000.0)
      {
        cout << "warning: very large data in point " << i << ", suspicious: " << end.transpose() << endl;
        warningSet = true;
      }
    }
    if (!endValid)
      continue;

    Vector3d normal;
    if (normalIsFloat)
    {
      Vector3f n = (Vector3f &)vertices[rowSize*i + normalOffset];
      normal = Vector3d(n[0], n[1], n[2]);
    }
    else
      normal = (Vector3d &)vertices[rowSize*i + normalOffset];
    bool normValid = normal==normal;
    if (!warningSet)
    {
      if (!normValid)
      {
        cout << "warning, NANs in raystart stored in normal " << i << ", removing all such rays." << endl;
        warningSet = true;
      }
      if (abs(normal[0]) > 100000.0)
      {
        cout << "warning: very large data in normal " << i << ", suspicious: " << normal.transpose() << endl;
        warningSet = true;
      }
    }
    if (!normValid)
      continue;

    ends.push_back(end);
    if (timeOffset != -1)
    {
      double time;
      if (timeIsFloat)
        time = (double)((float &)vertices[rowSize*i + timeOffset]);
      else
        time = (double &)vertices[rowSize*i + timeOffset];
      if (times.size() > 0 && times.back() > time)
        timesNeedSorting = true;
      times.push_back(time);
    }
    starts.push_back(end + normal);

    if (colourOffset != -1)
    {
      RGBA colour = (RGBA &)vertices[rowSize*i + colourOffset];
      colours.push_back(colour);
      if (colour.alpha > 0)
        numBounded++;
      else
        numUnbounded++;
    }
  }
  if (times.size() == 0)
  {
    cout << "warning: no time information found in " << fileName << ", setting times at 1 second intervals per ray" << endl;
    times.resize(ends.size());
    for (size_t i = 0; i < times.size(); i++)
      times[i] = (double)i;
  }
  if (colours.size() == 0)
  {
    cout << "warning: no colour information found in " << fileName << ", setting colours red->green->blue based on time" << endl;
    colourByTime(times, colours);
    numBounded = ends.size();
  }
  cout << "reading from " << fileName << ", " << size << " rays, of which " << numBounded << " bounded and " << numUnbounded << " unbounded" << endl;
  if (timesNeedSorting)
  {
    cout << "warning, ray times are not in order. This is required, so sorting rays now." << endl;
    struct Temp
    {
      double time;
      size_t index;
    };
    vector<Temp> timeList(times.size());
    for (size_t i = 0; i<timeList.size(); i++)
    {
      timeList[i].time = times[i];
      timeList[i].index = i;
    }
    sort(timeList.begin(), timeList.end(), [](const Temp &a, const Temp &b) {return a.time < b.time; });
    vector<Vector3d> newStarts(starts.size()), newEnds(ends.size());
    vector<double> newTimes(times.size());
    vector<RGBA> newColours(colours.size());
    for (size_t i = 0; i<starts.size(); i++)
    {
      newStarts[i] = starts[timeList[i].index];
      newEnds[i] = ends[timeList[i].index];
      newTimes[i] = timeList[i].time;
      newColours[i] = colours[timeList[i].index];
      if (i > 0 && newTimes[i] < newTimes[i-1])
        cout << "sorting failed" << endl;
    }
    starts = newStarts;
    ends = newEnds;
    times = newTimes;
    colours = newColours;
    cout << "finished sorting" << endl;
  }
  return true; 
}

void RAY::writePlyMesh(const string &fileName, const Mesh &mesh, bool flipNormals)
{
  cout << "saving to " << fileName << ", " << mesh.vertices.size() << " vertices." << endl;
  
  vector<Vector4f> vertices(mesh.vertices.size()); // 4d to give space for colour
  for (size_t i = 0; i<mesh.vertices.size(); i++)
    vertices[i] << (float)mesh.vertices[i][0], (float)mesh.vertices[i][1], (float)mesh.vertices[i][2], 1.0;


  FILE *fid = fopen(fileName.c_str(), "w+");
  fprintf(fid, "ply\n"); 
  fprintf(fid, "format binary_little_endian 1.0\n"); 
  fprintf(fid, "comment SDK generated\n"); // TODO: add version here
  fprintf(fid, "element vertex %u\n", unsigned(vertices.size())); 
  fprintf(fid, "property float x\n"); 
  fprintf(fid, "property float y\n"); 
  fprintf(fid, "property float z\n"); 
  fprintf(fid, "property uchar red\n"); 
  fprintf(fid, "property uchar green\n"); 
  fprintf(fid, "property uchar blue\n"); 
  fprintf(fid, "property uchar alpha\n"); 
  fprintf(fid, "element face %u\n", (unsigned)mesh.indexList.size()); 
  fprintf(fid, "property list int int vertex_indices\n"); 
  fprintf(fid, "end_header\n"); 

  fwrite(&vertices[0], sizeof(Vector4f), vertices.size(), fid);

  vector<Vector4i> triangles(mesh.indexList.size());
  if (flipNormals)
    for (size_t i = 0; i<mesh.indexList.size(); i++)
      triangles[i] = Vector4i(3, mesh.indexList[i][2], mesh.indexList[i][1], mesh.indexList[i][0]);
  else
    for (size_t i = 0; i<mesh.indexList.size(); i++)
      triangles[i] = Vector4i(3, mesh.indexList[i][0], mesh.indexList[i][1], mesh.indexList[i][2]);
  fwrite(&triangles[0], sizeof(Vector4i), triangles.size(), fid);
  fclose(fid);   
}


bool RAY::readPlyMesh(const string &file, Mesh &mesh)
{
  ifstream input(file.c_str());
  if (!input.is_open())
  {
    cerr << "Couldn't open file: " << file << endl;
    return false;
  }
  string line;
  unsigned rowSize = 0;
  unsigned numberOfFaces = 0;
  unsigned numberOfVertices = 0;
  char char1[100], char2[100];
  while (line != "end_header\r" && line != "end_header")
  {
    getline(input, line);
    if (line.find("float") != string::npos)
    {
      rowSize += 4;
    }
    if (line.find("property uchar") != string::npos)
    {
      rowSize ++;
    }
    if (line.find("element vertex") != string::npos)
      sscanf(line.c_str(), "%s %s %u", char1, char2, &numberOfVertices);
    if (line.find("element face") != string::npos)
      sscanf(line.c_str(), "%s %s %u", char1, char2, &numberOfFaces);    
  }
  
  vector<Vector4f> vertices(numberOfVertices);
  // read data as a block:
  input.read((char *)&vertices[0], sizeof(Vector4f) * vertices.size());
  vector<Vector4i> triangles(numberOfFaces);
  input.read((char *)&triangles[0], sizeof(Vector4i) * triangles.size());
  
  mesh.vertices.resize(vertices.size());
  for (int i = 0; i<(int)vertices.size(); i++)
    mesh.vertices[i] = Vector3d(vertices[i][0], vertices[i][1], vertices[i][2]);
 
  mesh.indexList.resize(triangles.size());
  for (int i = 0; i<(int)triangles.size(); i++)
    mesh.indexList[i] = Vector3i(triangles[i][1], triangles[i][2], triangles[i][3]);
  cout << "reading from " << file << ", " << mesh.indexList.size() << " triangles." << endl;
  return true;
}


